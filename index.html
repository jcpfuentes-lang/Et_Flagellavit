<script>
  // Marca el documento como listo para disparar la animación de entrada
  (function(){
    const markReady = () => requestAnimationFrame(() => document.body.classList.add('is-ready'));
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', markReady, { once:true });
    else markReady();
  })();

  const TRACKS = [{"name": "BOMBARDINO 1", "url": "audio/01_BOMBARDINO_1.mp3"}, {"name": "BOMBARDINO 2", "url": "audio/02_BOMBARDINO_2.mp3"}, {"name": "BOMBO Y PLATOS", "url": "audio/03_BOMBO_Y_PLATOS.mp3"}, {"name": "CAJA", "url": "audio/04_CAJA.mp3"}, {"name": "CORNETA", "url": "audio/05_CORNETA.mp3"}, {"name": "CUERDAS", "url": "audio/06_CUERDAS.mp3"}, {"name": "PERCU AUXILIAR", "url": "audio/07_PERCU_AUXILIAR.mp3"}, {"name": "TAMBOR DESTEMPLADO", "url": "audio/08_TAMBOR_DESTEMPLADO.mp3"}, {"name": "TAMBORES", "url": "audio/09_TAMBORES.mp3"}, {"name": "TROMBÓN 1", "url": "audio/10_TROMBON_1.mp3"}, {"name": "TROMBON 2", "url": "audio/11_TROMBON_2.mp3"}, {"name": "TROMPETA 1", "url": "audio/12_TROMPETA_1.mp3"}, {"name": "TROMPETA 2", "url": "audio/13_TROMPETA_2.mp3"}, {"name": "TROMPETA 3", "url": "audio/14_TROMPETA_3.mp3"}, {"name": "TUBA", "url": "audio/15_TUBA.mp3"}];

  // --- UI helpers ---
  const $ = (id) => document.getElementById(id);
  const toastEl = $("toast");
  function toast(msg) {
    toastEl.textContent = msg;
    toastEl.style.display = "block";
    clearTimeout(window.__toastTimer);
    window.__toastTimer = setTimeout(() => toastEl.style.display = "none", 4200);
  }
  function fmtTime(sec) {
    sec = Math.max(0, sec || 0);
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
  }

  // --- Audio engine ---
  let ac = null;
  let masterGain = null;
  let limiter = null;

  let buffers = [];            // AudioBuffer[]
  let nodes = [];              // {gain, pan, muted, solo}
  let sources = [];            // currently playing sources

  let isLoaded = false;
  let isPlaying = false;
  let loopOn = false;

  let startAt = 0;             // ac.currentTime when playback started
  let offset = 0;              // seconds into track when playback starts
  let duration = 0;            // seconds (max of buffers)
  let raf = null;

  // --- Seek (marcador temporal) ---
  const seek = $("seek");
  let seeking = false;

  const uiSeekTo = (valSec) => {
    const newOffset = Math.max(0, Math.min(duration, valSec));
    $("tCur").textContent = fmtTime(newOffset);
    $("clockBadge").textContent = fmtTime(newOffset) + " / " + fmtTime(duration);
  };

  // Pointer + Touch (móvil/iOS)
  seek.addEventListener("pointerdown", () => { seeking = true; }, {passive:true});
  window.addEventListener("pointerup", () => { seeking = false; }, {passive:true});
  seek.addEventListener("touchstart", () => { seeking = true; }, {passive:true});
  window.addEventListener("touchend", () => { seeking = false; }, {passive:true});

  seek.addEventListener("input", () => {
    if (!isLoaded) return;
    uiSeekTo(Number(seek.value));
  });

  seek.addEventListener("change", () => {
    if (!isLoaded) return;
    setOffset(Number(seek.value), true);
  });

  function ensureAudioContext() {
    if (ac) return;
    ac = new (window.AudioContext || window.webkitAudioContext)();

    masterGain = ac.createGain();
    masterGain.gain.value = Number($("masterVol").value);

    limiter = ac.createDynamicsCompressor();
    limiter.threshold.value = -6;
    limiter.knee.value = 0;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.003;
    limiter.release.value = 0.25;

    masterGain.connect(limiter);
    limiter.connect(ac.destination);

    $("masterVol").addEventListener("input", (e) => {
      if (!masterGain) return;
      // suave y sin clicks
      const v = Number(e.target.value);
      try{
        masterGain.gain.cancelScheduledValues(ac.currentTime);
        masterGain.gain.setTargetAtTime(v, ac.currentTime, 0.02);
      }catch(_){
        masterGain.gain.value = v;
      }
    });
  }

  function decodeArrayBuffer(arr) {
    return new Promise((resolve, reject) => {
      ac.decodeAudioData(arr, resolve, reject);
    });
  }

  function getConcurrency() {
    const hc = navigator.hardwareConcurrency || 4;
    return Math.max(2, Math.min(6, hc - 1));
  }

  async function mapLimit(items, limit, workerFn, progressFn) {
    const results = new Array(items.length);
    let next = 0, done = 0;

    const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
      while (true) {
        const i = next++;
        if (i >= items.length) break;
        results[i] = await workerFn(items[i], i);
        done++;
        if (progressFn) progressFn(done, items.length, items[i], i);
      }
    });

    await Promise.all(workers);
    return results;
  }

  async function loadAll() {
    // si estaba sonando, paramos antes de recargar
    if (isPlaying) stopPlayback();

    ensureAudioContext();
    $("statusBadge").textContent = "Cargando…";
    $("progressText").textContent = "Descargando y preparando audio…";
    $("progressPct").textContent = "0%";
    $("progressBar").style.width = "0%";

    const limit = getConcurrency();

    const bufs = await mapLimit(
      TRACKS,
      limit,
      async (tr) => {
        const res = await fetch(tr.url, { cache: "force-cache" });
        if (!res.ok) throw new Error("HTTP " + res.status + " (" + tr.url + ")");
        const arr = await res.arrayBuffer();
        const buf = await decodeArrayBuffer(arr);
        return buf;
      },
      (done, total, tr) => {
        const pct = Math.round((done / total) * 100);
        $("progressText").textContent = `Cargadas ${done}/${total}: ${tr.name}`;
        $("progressPct").textContent = pct + "%";
        $("progressBar").style.width = pct + "%";
      }
    );

    buffers = bufs;
    duration = Math.max(...buffers.map(b => b.duration));

    seek.max = String(duration);
    seek.step = "0.01";
    seek.value = "0";

    isLoaded = true;
    buildMixerUI();

    $("statusBadge").textContent = "Cargado";
    $("smallInfo").textContent = "Cargado. Pulsa Reproducir.";
    $("tDur").textContent = fmtTime(duration);
    $("clockBadge").textContent = "00:00 / " + fmtTime(duration);
    $("progressText").textContent = "Carga completa.";
    $("progressPct").textContent = "100%";
    $("progressBar").style.width = "100%";

    $("hero").classList.add("hidden");
    $("mixer").style.display = "grid";
    $("btnReload").classList.remove("hidden");
  }

  function buildMixerUI() {
    const wrap = $("tracks");
    wrap.innerHTML = "";
    // Refuerzo: una sola columna incluso si el navegador cachea CSS viejo
    wrap.style.gridTemplateColumns = "1fr";

    nodes = [];
    for (let i = 0; i < TRACKS.length; i++) {
      const tr = TRACKS[i];
      const card = document.createElement("div");
      card.className = "track";
      card.innerHTML = `
        <div class="trackTop">
          <div class="trackName">${tr.name}</div>
          <div class="pill">Pista ${String(i+1).padStart(2,"0")}</div>
        </div>

        <div class="controls">
          <div class="controlRow">
            <label><img class="iconSm" src="assets/icons/vol.svg" alt="">Vol</label>
            <input class="slider" data-kind="vol" data-i="${i}" type="range" min="0" max="2" step="0.01" value="1.0" />
          </div>

          <div class="controlRow">
            <label><img class="iconSm" src="assets/icons/pan.svg" alt="">Pan</label>
            <input class="slider" data-kind="pan" data-i="${i}" type="range" min="-1" max="1" step="0.01" value="0" />
          </div>

          <div class="btnRow">
            <button class="btn btnMini mute" data-kind="mute" data-i="${i}"><img class="iconSm" src="assets/icons/mute.svg" alt="">Mute</button>
            <button class="btn btnMini solo" data-kind="solo" data-i="${i}"><img class="iconSm" src="assets/icons/solo.svg" alt="">Solo</button>
          </div>
        </div>
      `;
      wrap.appendChild(card);

      nodes.push({ gain: 1.0, pan: 0, muted: false, solo: false });
    }

    wrap.querySelectorAll("input[data-kind]").forEach(el => {
      el.addEventListener("input", (e) => {
        const i = Number(e.target.dataset.i);
        const kind = e.target.dataset.kind;
        const v = Number(e.target.value);
        if (kind === "vol") nodes[i].gain = v;
        if (kind === "pan") nodes[i].pan = v;
        applyMixLive();
      });
    });

    wrap.querySelectorAll("button[data-kind]").forEach(btn => {
      btn.addEventListener("click", (e) => {
        const el = e.currentTarget;
        const i = Number(el.dataset.i);
        const kind = el.dataset.kind;

        if (kind === "mute") {
          nodes[i].muted = !nodes[i].muted;
          el.classList.toggle("on", nodes[i].muted);
        }
        if (kind === "solo") {
          nodes[i].solo = !nodes[i].solo;
          el.classList.toggle("on", nodes[i].solo);
        }
        applyMixLive();
      });
    });
  }

  function computeAudible(i) {
    const anySolo = nodes.some(n => n.solo);
    if (anySolo) return nodes[i].solo;
    return !nodes[i].muted;
  }

  // Cambios en tiempo real durante reproducción
  function applyMixLive() {
    if (!ac) return;
    for (let i = 0; i < sources.length; i++) {
      const s = sources[i];
      if (!s) continue;
      const audible = computeAudible(i);
      const g = audible ? nodes[i].gain : 0.0;
      try {
        s.gainNode.gain.cancelScheduledValues(ac.currentTime);
        s.gainNode.gain.setTargetAtTime(g, ac.currentTime, 0.02);

        if (s.panNode) {
          s.panNode.pan.cancelScheduledValues(ac.currentTime);
          s.panNode.pan.setTargetAtTime(nodes[i].pan, ac.currentTime, 0.02);
        }
      } catch (_) {}
    }
  }

  function stopSources() {
    for (const s of sources) {
      if (!s) continue;
      try { s.src.stop(0); } catch (_) {}
      try { s.src.disconnect(); } catch (_) {}
      try { s.gainNode.disconnect(); } catch (_) {}
      try { if (s.panNode) s.panNode.disconnect(); } catch (_) {}
    }
    sources = [];
  }

  function startPlayback() {
    if (!isLoaded) return;
    ensureAudioContext();
    if (ac.state === "suspended") ac.resume();

    stopSources();
    sources = [];

    const when = ac.currentTime + 0.08;
    startAt = when - offset;

    for (let i = 0; i < buffers.length; i++) {
      const buf = buffers[i];
      const src = ac.createBufferSource();
      src.buffer = buf;
      src.loop = loopOn;
      if (loopOn) { src.loopStart = 0; src.loopEnd = duration; }

      const gainNode = ac.createGain();
      const panNode = (ac.createStereoPanner) ? ac.createStereoPanner() : null;

      const audible = computeAudible(i);
      gainNode.gain.value = audible ? nodes[i].gain : 0.0;

      if (panNode) {
        panNode.pan.value = nodes[i].pan;
        src.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(masterGain);
      } else {
        src.connect(gainNode);
        gainNode.connect(masterGain);
      }

      const startOffset = Math.min(offset, Math.max(0, buf.duration - 0.001));
      src.start(when, startOffset);

      sources.push({ src, gainNode, panNode });
    }

    isPlaying = true;
    $("statusBadge").textContent = "Reproduciendo";
    applyMixLive(); // asegura estado actual de mute/solo/vol/pan
    tick();
  }

  function pausePlayback() {
    if (!isLoaded || !isPlaying) return;
    offset = getCurrentTime();
    stopSources();
    isPlaying = false;
    $("statusBadge").textContent = "En pausa";
    if (raf) cancelAnimationFrame(raf);
  }

  function stopPlayback() {
    if (!isLoaded) return;
    stopSources();
    isPlaying = false;
    offset = 0;
    $("statusBadge").textContent = "Detenido";
    updateClock(0);
    seek.value = "0";
    if (raf) cancelAnimationFrame(raf);
  }

  function setOffset(newOffset, restartIfPlaying) {
    offset = Math.max(0, Math.min(duration, newOffset));
    updateClock(offset);
    seek.value = String(offset);
    if (restartIfPlaying && isPlaying) startPlayback();
  }

  function getCurrentTime() {
    if (!isPlaying) return offset;
    const t = ac.currentTime - startAt;
    return Math.max(0, Math.min(duration, t));
  }

  function updateClock(t) {
    $("tCur").textContent = fmtTime(t);
    $("clockBadge").textContent = fmtTime(t) + " / " + fmtTime(duration);
  }

  function tick() {
    const t = getCurrentTime();
    updateClock(t);
    if (!seeking) seek.value = String(t);

    if (!loopOn && t >= duration - 0.02) {
      stopPlayback();
      return;
    }
    raf = requestAnimationFrame(tick);
  }

  // --- Buttons ---
  $("btnEnter").addEventListener("click", async () => {
    try {
      await loadAll();
      toast("Pistas cargadas. Consejo: usa SOLO para aislar instrumentos.");
    } catch (e) {
      console.error(e);
      $("statusBadge").textContent = "Error de carga";
      $("progressText").textContent = "Error. Revisa el hosting y rutas.";
      toast("Error cargando audios. Verifica que el hosting publica la carpeta 'audio/'.");
    }
  });

  $("btnReload").addEventListener("click", async () => {
    try{
      await loadAll();
      toast("Pistas recargadas.");
    }catch(e){
      console.error(e);
      toast("No se pudieron recargar las pistas.");
    }
  });

  function openTips(){
    const o = $("tipsOverlay");
    o.classList.add("on");
    o.setAttribute("aria-hidden","false");
  }
  function closeTips(){
    const o = $("tipsOverlay");
    o.classList.remove("on");
    o.setAttribute("aria-hidden","true");
  }
  $("btnTips").addEventListener("click", () => openTips());
  $("btnCloseTips").addEventListener("click", () => closeTips());
  $("tipsOverlay").addEventListener("click", (e) => {
    if (e.target && e.target.id === "tipsOverlay") closeTips();
  });
  window.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeTips(); });

  $("btnPlay").addEventListener("click", () => {
    if (!isLoaded) { toast("Primero pulsa “Entrar y cargar pistas”."); return; }
    startPlayback();
  });
  $("btnPause").addEventListener("click", () => pausePlayback());
  $("btnStop").addEventListener("click", () => stopPlayback());

  $("btnLoop").addEventListener("click", () => {
    loopOn = !loopOn;
    $("loopBadge").textContent = "Loop: " + (loopOn ? "ON" : "OFF");
    if (isPlaying) startPlayback();
  });

  $("btnResetMix").addEventListener("click", () => {
    if (!isLoaded) return;
    nodes.forEach(n => { n.gain = 1.0; n.pan = 0; n.muted = false; n.solo = false; });
    document.querySelectorAll("input[data-kind='vol']").forEach(el => el.value = "1.0");
    document.querySelectorAll("input[data-kind='pan']").forEach(el => el.value = "0");
    document.querySelectorAll("button[data-kind='mute']").forEach(el => el.classList.remove("on"));
    document.querySelectorAll("button[data-kind='solo']").forEach(el => el.classList.remove("on"));
    applyMixLive();
    toast("Mezcla reiniciada.");
  });
</script>
