<script>
"use strict";

/* =========================
   0) ANIMACIÓN (a prueba de fallos)
   ========================= */
(function(){
  const markReady = () => requestAnimationFrame(() => document.body.classList.add("is-ready"));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", markReady, { once:true });
  } else {
    markReady();
  }
})();

/* =========================
   1) TRACKS
   ========================= */
const TRACKS = [
  {"name":"BOMBARDINO 1","url":"audio/01_BOMBARDINO_1.mp3"},
  {"name":"BOMBARDINO 2","url":"audio/02_BOMBARDINO_2.mp3"},
  {"name":"BOMBO Y PLATOS","url":"audio/03_BOMBO_Y_PLATOS.mp3"},
  {"name":"CAJA","url":"audio/04_CAJA.mp3"},
  {"name":"CORNETA","url":"audio/05_CORNETA.mp3"},
  {"name":"CUERDAS","url":"audio/06_CUERDAS.mp3"},
  {"name":"PERCU AUXILIAR","url":"audio/07_PERCU_AUXILIAR.mp3"},
  {"name":"TAMBOR DESTEMPLADO","url":"audio/08_TAMBOR_DESTEMPLADO.mp3"},
  {"name":"TAMBORES","url":"audio/09_TAMBORES.mp3"},
  {"name":"TROMBÓN 1","url":"audio/10_TROMBON_1.mp3"},
  {"name":"TROMBON 2","url":"audio/11_TROMBON_2.mp3"},
  {"name":"TROMPETA 1","url":"audio/12_TROMPETA_1.mp3"},
  {"name":"TROMPETA 2","url":"audio/13_TROMPETA_2.mp3"},
  {"name":"TROMPETA 3","url":"audio/14_TROMPETA_3.mp3"},
  {"name":"TUBA","url":"audio/15_TUBA.mp3"}
];

/* =========================
   2) HELPERS UI
   ========================= */
const $ = (id) => document.getElementById(id);
const toastEl = $("toast");

function toast(msg){
  if(!toastEl) return;
  toastEl.textContent = msg;
  toastEl.style.display = "block";
  clearTimeout(window.__toastTimer);
  window.__toastTimer = setTimeout(() => toastEl.style.display = "none", 4200);
}
function fmtTime(sec){
  sec = Math.max(0, sec || 0);
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
}
function setStatus(t){
  const el = $("statusBadge");
  if(el) el.textContent = t;
}
function setProgress(text, pct){
  const t = $("progressText"); if(t) t.textContent = text;
  const p = $("progressPct");  if(p) p.textContent = pct + "%";
  const b = $("progressBar");  if(b) b.style.width = pct + "%";
}

/* =========================
   3) AUDIO ENGINE: MediaElement + WebAudio (mobile-friendly)
   ========================= */
let ac = null;
let masterGain = null;
let limiter = null;

let audioEls = [];   // HTMLAudioElement[]
let sources = [];    // {el, srcNode, gainNode, panNode}
let nodes = [];      // {gain, pan, muted, solo}

let isLoaded = false;
let isLoading = false;
let isPlaying = false;
let loopOn = false;

let duration = 0;
let raf = null;
let syncTimer = null;

/* --- Seek / Clock --- */
const seek = $("seek");
let seeking = false;

function getMasterEl(){
  return audioEls[0] || null;
}
function getCurrentTime(){
  const m = getMasterEl();
  return m ? (m.currentTime || 0) : 0;
}
function updateClock(){
  const t = getCurrentTime();
  const tCur = $("tCur"); if(tCur) tCur.textContent = fmtTime(t);
  const tDur = $("tDur"); if(tDur) tDur.textContent = fmtTime(duration);
  const clock = $("clockBadge"); if(clock) clock.textContent = fmtTime(t) + " / " + fmtTime(duration);
  if(seek && !seeking) seek.value = String(t);
}

function setOffsetAll(t){
  t = Math.max(0, Math.min(duration || 0, t));
  for(const a of audioEls){
    try{ a.currentTime = t; }catch(_){}
  }
  if(seek) seek.value = String(t);
  updateClock();
}

if(seek){
  seek.addEventListener("pointerdown", () => { seeking = true; }, {passive:true});
  window.addEventListener("pointerup", () => { seeking = false; }, {passive:true});
  seek.addEventListener("input", () => {
    if(!isLoaded) return;
    // mientras arrastras, solo actualiza UI (no “pelea” con el tick)
    const v = Number(seek.value);
    const tCur = $("tCur"); if(tCur) tCur.textContent = fmtTime(v);
    const clock = $("clockBadge"); if(clock) clock.textContent = fmtTime(v) + " / " + fmtTime(duration);
  });
  seek.addEventListener("change", () => {
    if(!isLoaded) return;
    setOffsetAll(Number(seek.value));
    // si está sonando, sigue sonando desde el nuevo punto (sin reiniciar motor)
    if(isPlaying){
      for(const a of audioEls){ a.play().catch(()=>{}); }
    }
  });
}

/* --- WebAudio master --- */
function ensureAudioContext(){
  if(ac) return;

  ac = new (window.AudioContext || window.webkitAudioContext)();

  masterGain = ac.createGain();
  masterGain.gain.value = Number($("masterVol")?.value ?? 1.5);

  limiter = ac.createDynamicsCompressor();
  limiter.threshold.value = -10;  // más permisivo para subir master
  limiter.knee.value = 0;
  limiter.ratio.value = 20;
  limiter.attack.value = 0.003;
  limiter.release.value = 0.25;

  masterGain.connect(limiter);
  limiter.connect(ac.destination);

  const masterVol = $("masterVol");
  if(masterVol){
    masterVol.addEventListener("input", (e) => {
      if(!masterGain) return;
      const v = Number(e.target.value);
      masterGain.gain.cancelScheduledValues(ac.currentTime);
      masterGain.gain.setTargetAtTime(v, ac.currentTime, 0.02);
    });
  }
}

/* =========================
   4) CARGA (streaming, sin decodificar buffers)
   ========================= */
function makeAudioEl(url){
  const a = new Audio();
  a.src = url;
  a.preload = "auto";
  a.crossOrigin = "anonymous";
  a.loop = false;
  a.playsInline = true; // iOS
  return a;
}

function waitMetadata(a){
  return new Promise((resolve, reject) => {
    const onOk = () => cleanup(resolve);
    const onErr = () => cleanup(() => reject(new Error("Error cargando audio: " + a.src)));
    const cleanup = (fn) => {
      a.removeEventListener("loadedmetadata", onOk);
      a.removeEventListener("error", onErr);
      fn();
    };
    a.addEventListener("loadedmetadata", onOk, { once:true });
    a.addEventListener("error", onErr, { once:true });
    // por si ya estaba
    if(!isNaN(a.duration) && isFinite(a.duration) && a.duration > 0) cleanup(resolve);
  });
}

async function loadAll(){
  if(isLoading) return;
  isLoading = true;

  try{
    setStatus("Cargando…");
    setProgress("Preparando pistas…", 0);

    // parar si está sonando
    stopPlayback();

    // reset (importante en móvil)
    audioEls = [];
    sources = [];
    nodes = [];

    ensureAudioContext();
    if(ac.state === "suspended") await ac.resume();

    // crear audios y nodos
    audioEls = TRACKS.map(t => makeAudioEl(t.url));

    // Progreso por metadata (rápido y fiable en móvil)
    let done = 0;
    const total = audioEls.length;

    for(let i = 0; i < audioEls.length; i++){
      const a = audioEls[i];
      setProgress(`Cargando metadata ${i+1}/${total}: ${TRACKS[i].name}`, Math.round((i/total)*100));
      await waitMetadata(a);
      done++;
      setProgress(`Listo ${done}/${total}: ${TRACKS[i].name}`, Math.round((done/total)*100));
    }

    // Duración (tomamos el máximo)
    duration = Math.max(...audioEls.map(a => a.duration || 0));

    if(seek){
      seek.max = String(duration);
      seek.step = "0.01";
      seek.value = "0";
    }

    // Conectar cada audio al grafo WebAudio
    for(let i = 0; i < audioEls.length; i++){
      const el = audioEls[i];
      const srcNode = ac.createMediaElementSource(el);
      const gainNode = ac.createGain();
      const panNode = ac.createStereoPanner ? ac.createStereoPanner() : null;

      // estado inicial
      nodes.push({ gain: 1.0, pan: 0, muted: false, solo: false });
      gainNode.gain.value = 1.0;

      if(panNode){
        panNode.pan.value = 0;
        srcNode.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(masterGain);
      } else {
        srcNode.connect(gainNode);
        gainNode.connect(masterGain);
      }

      sources.push({ el, srcNode, gainNode, panNode });
    }

    // UI
    buildMixerUI();

    isLoaded = true;
    setStatus("Cargado");
    setProgress("Carga completa.", 100);
    updateClock();

    const small = $("smallInfo"); if(small) small.textContent = "Cargado. Pulsa Reproducir.";

    const hero = $("hero");   if(hero) hero.style.display = "none";
    const mixer = $("mixer"); if(mixer) mixer.style.display = "grid";
    const btnReload = $("btnReload"); if(btnReload) btnReload.classList.remove("hidden");

    toast("Pistas cargadas (modo streaming).");
  } finally {
    isLoading = false;
  }
}

/* =========================
   5) UI pistas (1 columna + controles live)
   ========================= */
function buildMixerUI(){
  const wrap = $("tracks");
  if(!wrap) return;

  // fuerza 1 columna incluso si el CSS se pisa
  wrap.style.display = "grid";
  wrap.style.gridTemplateColumns = "1fr";
  wrap.style.gap = "12px";

  wrap.innerHTML = "";

  for(let i = 0; i < TRACKS.length; i++){
    const tr = TRACKS[i];
    const card = document.createElement("div");
    card.className = "track";
    card.innerHTML = `
      <div class="trackTop">
        <div class="trackName">${tr.name}</div>
        <div class="pill">Pista ${String(i+1).padStart(2,"0")}</div>
      </div>

      <div class="controls">
        <div class="controlRow">
          <label><img class="iconSm" src="assets/icons/vol.svg" alt="">Vol</label>
          <input class="slider" data-kind="vol" data-i="${i}" type="range" min="0" max="3" step="0.01" value="1.0" />
        </div>

        <div class="controlRow">
          <label><img class="iconSm" src="assets/icons/pan.svg" alt="">Pan</label>
          <input class="slider" data-kind="pan" data-i="${i}" type="range" min="-1" max="1" step="0.01" value="0" />
        </div>

        <div class="btnRow">
          <button class="btn btnMini" data-kind="mute" data-i="${i}">
            <img class="iconSm" src="assets/icons/mute.svg" alt="">Mute
          </button>
          <button class="btn btnMini" data-kind="solo" data-i="${i}">
            <img class="iconSm" src="assets/icons/solo.svg" alt="">Solo
          </button>
        </div>
      </div>
    `;
    wrap.appendChild(card);
  }

  // sliders
  wrap.querySelectorAll("input[data-kind]").forEach(el => {
    el.addEventListener("input", (e) => {
      const i = Number(e.target.dataset.i);
      const kind = e.target.dataset.kind;
      const v = Number(e.target.value);
      if(kind === "vol") nodes[i].gain = v;
      if(kind === "pan") nodes[i].pan = v;
      applyMixLive();
    });
  });

  // botones (currentTarget para que funcione aunque pulses el icono)
  wrap.querySelectorAll("button[data-kind]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      const el = e.currentTarget;
      const i = Number(el.dataset.i);
      const kind = el.dataset.kind;

      if(kind === "mute"){
        nodes[i].muted = !nodes[i].muted;
        el.classList.toggle("on", nodes[i].muted);
      } else if(kind === "solo"){
        nodes[i].solo = !nodes[i].solo;
        el.classList.toggle("on", nodes[i].solo);
      }
      applyMixLive();
    });
  });
}

/* =========================
   6) Mezcla live (gain/pan)
   ========================= */
function computeAudible(i){
  const anySolo = nodes.some(n => n.solo);
  if(anySolo) return nodes[i].solo;
  return !nodes[i].muted;
}

function applyMixLive(){
  if(!ac || sources.length === 0) return;

  for(let i = 0; i < sources.length; i++){
    const s = sources[i];
    const audible = computeAudible(i);
    const g = audible ? nodes[i].gain : 0.0;

    s.gainNode.gain.cancelScheduledValues(ac.currentTime);
    s.gainNode.gain.setTargetAtTime(g, ac.currentTime, 0.02);

    if(s.panNode){
      s.panNode.pan.cancelScheduledValues(ac.currentTime);
      s.panNode.pan.setTargetAtTime(nodes[i].pan, ac.currentTime, 0.02);
    }
  }
}

/* =========================
   7) Transporte (play/pause/stop/loop) + sync guard
   ========================= */
function clearTimers(){
  if(raf) cancelAnimationFrame(raf);
  raf = null;
  if(syncTimer) clearInterval(syncTimer);
  syncTimer = null;
}

function tick(){
  updateClock();
  raf = requestAnimationFrame(tick);
}

function startSyncGuard(){
  // corrige drift en móvil cada 400ms (solo si se desincroniza >80ms)
  syncTimer = setInterval(() => {
    if(!isPlaying) return;
    const m = getMasterEl();
    if(!m) return;
    const t = m.currentTime || 0;
    for(let i = 1; i < audioEls.length; i++){
      const a = audioEls[i];
      const d = Math.abs((a.currentTime || 0) - t);
      if(d > 0.08){
        try{ a.currentTime = t; }catch(_){}
      }
    }
  }, 400);
}

async function startPlayback(){
  if(!isLoaded) { toast("Primero pulsa “Entrar y cargar pistas”."); return; }
  ensureAudioContext();
  if(ac.state === "suspended") await ac.resume();

  // al iniciar, alineamos todas
  const t = Number(seek?.value ?? 0);
  setOffsetAll(t);

  // play todas
  const plays = audioEls.map(a => a.play().catch(err => err));
  const results = await Promise.all(plays);

  // si alguna falló en iOS por gesto, lo avisamos
  const anyFail = results.some(r => r instanceof Error);
  if(anyFail){
    toast("En móvil, si no suena: vuelve a pulsar Reproducir (iOS exige gesto).");
  }

  isPlaying = true;
  setStatus("Reproduciendo");
  clearTimers();
  tick();
  startSyncGuard();

  // loop: cuando termina la master
  const m = getMasterEl();
  if(m){
    m.onended = () => {
      if(loopOn){
        setOffsetAll(0);
        startPlayback();
      } else {
        stopPlayback();
      }
    };
  }
}

function pausePlayback(){
  if(!isLoaded || !isPlaying) return;
  for(const a of audioEls){ try{ a.pause(); }catch(_){ } }
  isPlaying = false;
  setStatus("En pausa");
  clearTimers();
  updateClock();
}

function stopPlayback(){
  if(!isLoaded && audioEls.length === 0) return;
  for(const a of audioEls){
    try{ a.pause(); }catch(_){}
    try{ a.currentTime = 0; }catch(_){}
  }
  isPlaying = false;
  setStatus("Detenido");
  clearTimers();
  if(seek) seek.value = "0";
  updateClock();
}

/* =========================
   8) Botones
   ========================= */
$("btnEnter")?.addEventListener("click", async () => {
  try{
    await loadAll();
  }catch(e){
    console.error(e);
    setStatus("Error de carga");
    setProgress("Error. Revisa rutas en /audio/.", 0);
    toast("Error cargando pistas. Comprueba carpeta /audio/ y nombres exactos.");
  }
});

$("btnReload")?.addEventListener("click", async () => {
  try{
    await loadAll();
    toast("Pistas recargadas.");
  }catch(e){
    console.error(e);
    toast("No se pudieron recargar.");
  }
});

$("btnPlay")?.addEventListener("click", () => startPlayback());
$("btnPause")?.addEventListener("click", () => pausePlayback());
$("btnStop")?.addEventListener("click", () => stopPlayback());

$("btnLoop")?.addEventListener("click", () => {
  loopOn = !loopOn;
  const lb = $("loopBadge"); if(lb) lb.textContent = "Loop: " + (loopOn ? "ON" : "OFF");
  toast("Loop " + (loopOn ? "activado" : "desactivado"));
});

$("btnResetMix")?.addEventListener("click", () => {
  if(!isLoaded) return;
  nodes.forEach(n => { n.gain = 1.0; n.pan = 0; n.muted = false; n.solo = false; });

  document.querySelectorAll("input[data-kind='vol']").forEach(el => el.value = "1.0");
  document.querySelectorAll("input[data-kind='pan']").forEach(el => el.value = "0");
  document.querySelectorAll("button[data-kind='mute']").forEach(el => el.classList.remove("on"));
  document.querySelectorAll("button[data-kind='solo']").forEach(el => el.classList.remove("on"));

  applyMixLive();
  toast("Mezcla reiniciada.");
});

/* =========================
   9) Tips overlay
   ========================= */
function openTips(){
  const o = $("tipsOverlay");
  if(!o) return;
  o.classList.add("on");
  o.setAttribute("aria-hidden","false");
}
function closeTips(){
  const o = $("tipsOverlay");
  if(!o) return;
  o.classList.remove("on");
  o.setAttribute("aria-hidden","true");
}
$("btnTips")?.addEventListener("click", () => openTips());
$("btnCloseTips")?.addEventListener("click", () => closeTips());
$("tipsOverlay")?.addEventListener("click", (e) => {
  if (e.target && e.target.id === "tipsOverlay") closeTips();
});
window.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeTips(); });
</script>
