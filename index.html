<script>
"use strict";

/* =========================
   0) ANIMACIÓN (segura)
   ========================= */
(function(){
  // Si el script grande falla en alguna parte, el head ya mete is-ready.
  // Esto es redundante pero no molesta.
  const markReady = () => requestAnimationFrame(() => document.body.classList.add("is-ready"));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", markReady, { once:true });
  } else {
    markReady();
  }
})();

/* =========================
   1) CONFIG: TRACKS
   ========================= */
const TRACKS = [
  {"name":"BOMBARDINO 1","url":"audio/01_BOMBARDINO_1.mp3"},
  {"name":"BOMBARDINO 2","url":"audio/02_BOMBARDINO_2.mp3"},
  {"name":"BOMBO Y PLATOS","url":"audio/03_BOMBO_Y_PLATOS.mp3"},
  {"name":"CAJA","url":"audio/04_CAJA.mp3"},
  {"name":"CORNETA","url":"audio/05_CORNETA.mp3"},
  {"name":"CUERDAS","url":"audio/06_CUERDAS.mp3"},
  {"name":"PERCU AUXILIAR","url":"audio/07_PERCU_AUXILIAR.mp3"},
  {"name":"TAMBOR DESTEMPLADO","url":"audio/08_TAMBOR_DESTEMPLADO.mp3"},
  {"name":"TAMBORES","url":"audio/09_TAMBORES.mp3"},
  {"name":"TROMBÓN 1","url":"audio/10_TROMBON_1.mp3"},
  {"name":"TROMBON 2","url":"audio/11_TROMBON_2.mp3"},
  {"name":"TROMPETA 1","url":"audio/12_TROMPETA_1.mp3"},
  {"name":"TROMPETA 2","url":"audio/13_TROMPETA_2.mp3"},
  {"name":"TROMPETA 3","url":"audio/14_TROMPETA_3.mp3"},
  {"name":"TUBA","url":"audio/15_TUBA.mp3"}
];

/* =========================
   2) HELPERS UI
   ========================= */
const $ = (id) => document.getElementById(id);

const toastEl = $("toast");
function toast(msg){
  if(!toastEl) return;
  toastEl.textContent = msg;
  toastEl.style.display = "block";
  clearTimeout(window.__toastTimer);
  window.__toastTimer = setTimeout(() => toastEl.style.display = "none", 4200);
}
function fmtTime(sec){
  sec = Math.max(0, sec || 0);
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
}
function setStatus(t){
  const el = $("statusBadge");
  if(el) el.textContent = t;
}
function setProgress(text, pct){
  const t = $("progressText"); if(t) t.textContent = text;
  const p = $("progressPct");  if(p) p.textContent = pct + "%";
  const b = $("progressBar");  if(b) b.style.width = pct + "%";
}

/* =========================
   3) AUDIO ENGINE (WebAudio)
   ========================= */
let ac = null;
let masterGain = null;
let limiter = null;

let buffers = [];   // AudioBuffer[]
let nodes = [];     // {gain, pan, muted, solo}
let sources = [];   // {src, gainNode, panNode}

let isLoaded = false;
let isLoading = false;
let isPlaying = false;
let loopOn = false;

let startAt = 0;    // ac.currentTime - offset
let offset = 0;     // seconds
let duration = 0;   // seconds
let raf = null;

/* --- Seek control (scrub sin pelea con el refresco) --- */
const seek = $("seek");
let seeking = false;

function updateClock(t){
  const tCur = $("tCur"); if(tCur) tCur.textContent = fmtTime(t);
  const tDur = $("tDur"); if(tDur) tDur.textContent = fmtTime(duration);
  const clock = $("clockBadge"); if(clock) clock.textContent = fmtTime(t) + " / " + fmtTime(duration);
}
function getCurrentTime(){
  if(!isPlaying) return offset;
  const t = ac.currentTime - startAt;
  return Math.max(0, Math.min(duration, t));
}
function setOffset(newOffset, restartIfPlaying){
  offset = Math.max(0, Math.min(duration, newOffset));
  updateClock(offset);
  if(seek) seek.value = String(offset);
  if(restartIfPlaying && isPlaying) startPlayback();
}
function tick(){
  const t = getCurrentTime();
  updateClock(t);
  if(seek && !seeking) seek.value = String(t);

  if(!loopOn && t >= duration - 0.02){
    stopPlayback();
    return;
  }
  raf = requestAnimationFrame(tick);
}

if(seek){
  seek.addEventListener("pointerdown", () => { seeking = true; }, {passive:true});
  window.addEventListener("pointerup", () => { seeking = false; }, {passive:true});

  seek.addEventListener("input", () => {
    if(!isLoaded) return;
    const v = Number(seek.value);
    updateClock(v);
  });

  seek.addEventListener("change", () => {
    if(!isLoaded) return;
    setOffset(Number(seek.value), true);
  });
}

/* --- AudioContext + Master + Limiter --- */
function ensureAudioContext(){
  if(ac) return;

  ac = new (window.AudioContext || window.webkitAudioContext)();

  masterGain = ac.createGain();
  masterGain.gain.value = Number($("masterVol")?.value ?? 1.2);

  // Limiter para permitir subir volumen sin distorsión fea
  limiter = ac.createDynamicsCompressor();
  limiter.threshold.value = -8;
  limiter.knee.value = 0;
  limiter.ratio.value = 20;
  limiter.attack.value = 0.003;
  limiter.release.value = 0.25;

  masterGain.connect(limiter);
  limiter.connect(ac.destination);

  const masterVol = $("masterVol");
  if(masterVol){
    masterVol.addEventListener("input", (e) => {
      if(!masterGain) return;
      const v = Number(e.target.value);
      masterGain.gain.cancelScheduledValues(ac.currentTime);
      masterGain.gain.setTargetAtTime(v, ac.currentTime, 0.02);
    });
  }
}

function decodeArrayBuffer(arr){
  return new Promise((resolve, reject) => {
    ac.decodeAudioData(arr, resolve, reject);
  });
}

function getConcurrency(){
  const hc = navigator.hardwareConcurrency || 4;
  return Math.max(2, Math.min(6, hc - 1));
}

async function mapLimit(items, limit, workerFn, progressFn){
  const results = new Array(items.length);
  let next = 0, done = 0;

  const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
    while(true){
      const i = next++;
      if(i >= items.length) break;
      results[i] = await workerFn(items[i], i);
      done++;
      if(progressFn) progressFn(done, items.length, items[i], i);
    }
  });

  await Promise.all(workers);
  return results;
}

/* =========================
   4) CARGA (rápida)
   ========================= */
async function loadAll(){
  if(isLoading) return;
  isLoading = true;

  try{
    ensureAudioContext();
    if(ac.state === "suspended") await ac.resume();

    setStatus("Cargando…");
    setProgress("Descargando y preparando audio…", 0);

    // Si estaba sonando, paramos antes de recargar
    if(isPlaying) stopPlayback();

    const limit = getConcurrency();

    const bufs = await mapLimit(
      TRACKS,
      limit,
      async (tr) => {
        const res = await fetch(tr.url, { cache: "force-cache" });
        if(!res.ok) throw new Error("No se pudo cargar: " + tr.url + " (HTTP " + res.status + ")");
        const arr = await res.arrayBuffer();
        return await decodeArrayBuffer(arr);
      },
      (done, total, tr) => {
        const pct = Math.round((done / total) * 100);
        setProgress(`Cargadas ${done}/${total}: ${tr.name}`, pct);
      }
    );

    buffers = bufs;
    duration = Math.max(...buffers.map(b => b.duration));
    offset = 0;

    // Seek en segundos
    if(seek){
      seek.max = String(duration);
      seek.step = "0.01";
      seek.value = "0";
    }

    isLoaded = true;

    buildMixerUI();
    updateClock(0);

    setStatus("Cargado");
    setProgress("Carga completa.", 100);

    const small = $("smallInfo"); if(small) small.textContent = "Cargado. Pulsa Reproducir.";

    // Mostrar mixer
    const hero = $("hero");   if(hero) hero.style.display = "none";
    const mixer = $("mixer"); if(mixer) mixer.style.display = "grid";
    const btnReload = $("btnReload"); if(btnReload) btnReload.classList.remove("hidden");

    toast("Pistas cargadas. Usa SOLO para aislar instrumentos.");
  } finally {
    isLoading = false;
  }
}

/* =========================
   5) UI de pistas (1 columna)
   ========================= */
function buildMixerUI(){
  const wrap = $("tracks");
  if(!wrap) return;

  wrap.innerHTML = "";
  nodes = [];

  for(let i = 0; i < TRACKS.length; i++){
    const tr = TRACKS[i];
    const card = document.createElement("div");
    card.className = "track";

    card.innerHTML = `
      <div class="trackTop">
        <div class="trackName">${tr.name}</div>
        <div class="pill">Pista ${String(i+1).padStart(2,"0")}</div>
      </div>

      <div class="controls">
        <div class="controlRow">
          <label><img class="iconSm" src="assets/icons/vol.svg" alt="">Vol</label>
          <input class="slider" data-kind="vol" data-i="${i}" type="range" min="0" max="2" step="0.01" value="1.0" />
        </div>

        <div class="controlRow">
          <label><img class="iconSm" src="assets/icons/pan.svg" alt="">Pan</label>
          <input class="slider" data-kind="pan" data-i="${i}" type="range" min="-1" max="1" step="0.01" value="0" />
        </div>

        <div class="btnRow">
          <button class="btn btnMini" data-kind="mute" data-i="${i}">
            <img class="iconSm" src="assets/icons/mute.svg" alt="">Mute
          </button>
          <button class="btn btnMini" data-kind="solo" data-i="${i}">
            <img class="iconSm" src="assets/icons/solo.svg" alt="">Solo
          </button>
        </div>
      </div>
    `;

    wrap.appendChild(card);

    nodes.push({ gain: 1.0, pan: 0, muted: false, solo: false });
  }

  // Sliders
  wrap.querySelectorAll("input[data-kind]").forEach(el => {
    el.addEventListener("input", (e) => {
      const i = Number(e.target.dataset.i);
      const kind = e.target.dataset.kind;
      const v = Number(e.target.value);

      if(kind === "vol") nodes[i].gain = v;
      if(kind === "pan") nodes[i].pan = v;

      applyMixLive();
    });
  });

  // Botones: OJO, usamos currentTarget (si pulsas el icono, sigue funcionando)
  wrap.querySelectorAll("button[data-kind]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      const el = e.currentTarget;
      const i = Number(el.dataset.i);
      const kind = el.dataset.kind;

      if(kind === "mute"){
        nodes[i].muted = !nodes[i].muted;
        el.classList.toggle("on", nodes[i].muted);
      } else if(kind === "solo"){
        nodes[i].solo = !nodes[i].solo;
        el.classList.toggle("on", nodes[i].solo);
      }

      applyMixLive();
    });
  });
}

/* =========================
   6) Mezcla en vivo
   ========================= */
function computeAudible(i){
  const anySolo = nodes.some(n => n.solo);
  if(anySolo) return nodes[i].solo;
  return !nodes[i].muted;
}

function applyMixLive(){
  if(!ac || sources.length === 0) return;

  for(let i = 0; i < sources.length; i++){
    const s = sources[i];
    if(!s) continue;

    const audible = computeAudible(i);
    const g = audible ? nodes[i].gain : 0.0;

    try{
      s.gainNode.gain.cancelScheduledValues(ac.currentTime);
      s.gainNode.gain.setTargetAtTime(g, ac.currentTime, 0.02);

      if(s.panNode){
        s.panNode.pan.cancelScheduledValues(ac.currentTime);
        s.panNode.pan.setTargetAtTime(nodes[i].pan, ac.currentTime, 0.02);
      }
    }catch(_){}
  }
}

/* =========================
   7) Transporte
   ========================= */
function stopSources(){
  for(const s of sources){
    if(!s) continue;
    try{ s.src.stop(0); }catch(_){}
    try{ s.src.disconnect(); }catch(_){}
    try{ s.gainNode.disconnect(); }catch(_){}
    try{ if(s.panNode) s.panNode.disconnect(); }catch(_){}
  }
  sources = [];
}

function startPlayback(){
  if(!isLoaded) return;
  ensureAudioContext();
  if(ac.state === "suspended") ac.resume();

  stopSources();
  sources = [];

  const when = ac.currentTime + 0.08;
  startAt = when - offset;

  for(let i = 0; i < buffers.length; i++){
    const buf = buffers[i];

    const src = ac.createBufferSource();
    src.buffer = buf;
    src.loop = loopOn;
    if(loopOn){
      src.loopStart = 0;
      src.loopEnd = duration;
    }

    const gainNode = ac.createGain();
    const panNode = (ac.createStereoPanner) ? ac.createStereoPanner() : null;

    const audible = computeAudible(i);
    gainNode.gain.value = audible ? nodes[i].gain : 0.0;

    if(panNode){
      panNode.pan.value = nodes[i].pan;
      src.connect(gainNode);
      gainNode.connect(panNode);
      panNode.connect(masterGain);
    } else {
      src.connect(gainNode);
      gainNode.connect(masterGain);
    }

    const startOffset = Math.min(offset, Math.max(0, buf.duration - 0.001));
    src.start(when, startOffset);

    sources.push({ src, gainNode, panNode });
  }

  isPlaying = true;
  setStatus("Reproduciendo");
  applyMixLive();
  tick();
}

function pausePlayback(){
  if(!isLoaded || !isPlaying) return;
  offset = getCurrentTime();
  stopSources();
  isPlaying = false;
  setStatus("En pausa");
  if(raf) cancelAnimationFrame(raf);
}

function stopPlayback(){
  if(!isLoaded) return;
  stopSources();
  isPlaying = false;
  offset = 0;
  setStatus("Detenido");
  updateClock(0);
  if(seek) seek.value = "0";
  if(raf) cancelAnimationFrame(raf);
}

/* =========================
   8) Botones + Tips
   ========================= */
$("btnEnter")?.addEventListener("click", async () => {
  try{
    await loadAll();
  }catch(e){
    console.error(e);
    setStatus("Error de carga");
    setProgress("Error. Revisa el hosting y rutas.", 0);
    toast("Error cargando audios. Comprueba que existe la carpeta 'audio/' y los nombres exactos.");
  }
});

$("btnReload")?.addEventListener("click", async () => {
  try{
    await loadAll();
    toast("Pistas recargadas.");
  }catch(e){
    console.error(e);
    toast("No se pudieron recargar las pistas.");
  }
});

$("btnPlay")?.addEventListener("click", () => {
  if(!isLoaded){ toast("Primero pulsa “Entrar y cargar pistas”."); return; }
  startPlayback();
});
$("btnPause")?.addEventListener("click", pausePlayback);
$("btnStop")?.addEventListener("click", stopPlayback);

$("btnLoop")?.addEventListener("click", () => {
  loopOn = !loopOn;
  const lb = $("loopBadge"); if(lb) lb.textContent = "Loop: " + (loopOn ? "ON" : "OFF");
  if(isPlaying) startPlayback();
});

$("btnResetMix")?.addEventListener("click", () => {
  if(!isLoaded) return;

  nodes.forEach(n => { n.gain = 1.0; n.pan = 0; n.muted = false; n.solo = false; });

  document.querySelectorAll("input[data-kind='vol']").forEach(el => el.value = "1.0");
  document.querySelectorAll("input[data-kind='pan']").forEach(el => el.value = "0");
  document.querySelectorAll("button[data-kind='mute']").forEach(el => el.classList.remove("on"));
  document.querySelectorAll("button[data-kind='solo']").forEach(el => el.classList.remove("on"));

  applyMixLive();
  toast("Mezcla reiniciada.");
});

// Tips overlay
function openTips(){
  const o = $("tipsOverlay");
  if(!o) return;
  o.classList.add("on");
  o.setAttribute("aria-hidden","false");
}
function closeTips(){
  const o = $("tipsOverlay");
  if(!o) return;
  o.classList.remove("on");
  o.setAttribute("aria-hidden","true");
}
$("btnTips")?.addEventListener("click", openTips);
$("btnCloseTips")?.addEventListener("click", closeTips);
$("tipsOverlay")?.addEventListener("click", (e) => {
  if(e.target && e.target.id === "tipsOverlay") closeTips();
});
window.addEventListener("keydown", (e) => { if(e.key === "Escape") closeTips(); });
</script>
